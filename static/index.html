<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Гадалка</title>
    <script src="https://telegram.org/js/telegram-web-app.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: var(--tg-theme-text-color, #000000);
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--tg-theme-button-color, #cccccc);
            border-radius: 4px;
            background-color: var(--tg-theme-secondary-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
        }
        button {
            background-color: var(--tg-theme-button-color, #3390ec);
            color: var(--tg-theme-button-text-color, #ffffff);
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .prediction {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            background-color: var(--tg-theme-secondary-bg-color, #f5f5f5);
        }
        .prediction img {
            max-width: 100%;
            height: auto;
            margin-top: 10px;
            border-radius: 4px;
        }
        .preloader {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .preloader::after {
            content: '';
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid var(--tg-theme-button-color, #3390ec);
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <div class="form-group">
        <label for="name">Ваше имя:</label>
        <input type="text" id="name" name="name" required>
    </div>
    <div class="form-group">
        <label for="birthDate">Дата рождения:</label>
        <input type="text" id="birthDate" name="birthDate" placeholder="ДД.ММ.ГГГГ" required>
    </div>
    <div class="form-group">
        <label for="question">Ваш вопрос:</label>
        <input type="text" id="question" name="question" required>
    </div>
    <div class="form-group">
        <label for="mode">Сфера вопроса:</label>
        <select id="mode" name="mode" required>
            <option value="">Выберите сферу</option>
            <option value="Любовь">Любовь</option>
            <option value="Карьера">Карьера</option>
            <option value="Здоровье">Здоровье</option>
            <option value="Финансы">Финансы</option>
            <option value="Семья">Семья</option>
            <option value="Другое">Другое</option>
        </select>
    </div>
    <div class="form-group">
        <label for="partnerName">Имя партнера (если применимо):</label>
        <input type="text" id="partnerName" name="partnerName">
    </div>
    <div class="form-group">
        <label for="partnerBirth">Дата рождения партнера (если применимо):</label>
        <input type="text" id="partnerBirth" name="partnerBirth" placeholder="ДД.ММ.ГГГГ">
    </div>
    <button id="getPrediction" onclick="getPrediction()">Получить предсказание</button>
    <div id="preloader" class="preloader"></div>
    <div id="prediction" class="prediction" style="display: none;"></div>

    <script>
        // Инициализация Telegram Web App только один раз
        let tg;
        if (window.Telegram && window.Telegram.WebApp) {
            tg = window.Telegram.WebApp;
            tg.expand();
            tg.ready();
        }

        let currentController = null;

        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    console.log(`Попытка ${i + 1} из ${maxRetries}`);
                    
                    // Отменяем предыдущий контроллер, если он существует
                    if (currentController) {
                        console.log('Отмена предыдущего запроса');
                        currentController.abort();
                    }
                    currentController = new AbortController();
                    
                    const timeoutId = setTimeout(() => {
                        console.log('Таймаут запроса');
                        currentController.abort();
                        currentController = null;
                    }, 300000); // 5 minutes timeout
                    
                    console.log('Отправка запроса:', {
                        url: url,
                        method: options.method,
                        headers: options.headers
                    });
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: currentController.signal,
                        headers: {
                            ...options.headers,
                            'Accept': 'application/json',
                            'Cache-Control': 'no-store, no-cache, must-revalidate',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    currentController = null;
                    
                    console.log('Получен ответ:', {
                        status: response.status,
                        statusText: response.statusText,
                        headers: Object.fromEntries(response.headers.entries())
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Ошибка ответа:', errorText);
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }
                    
                    return response;
                } catch (error) {
                    console.error('Ошибка запроса:', error);
                    if (error.name === 'AbortError') {
                        console.log('Запрос был отменен');
                        if (i === maxRetries - 1) {
                            throw new Error('Превышено время ожидания ответа от сервера');
                        }
                    } else if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.log(`Повторная попытка через 2 секунды. Осталось попыток: ${maxRetries - i - 1}`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }

        async function getPrediction() {
            const name = document.getElementById('name').value;
            const birthDate = document.getElementById('birthDate').value;
            const question = document.getElementById('question').value;
            const mode = document.getElementById('mode').value;
            const partnerName = document.getElementById('partnerName').value;
            const partnerBirth = document.getElementById('partnerBirth').value;

            if (!name || !birthDate || !question || !mode) {
                alert('Пожалуйста, заполните все обязательные поля');
                return;
            }

            const button = document.getElementById('getPrediction');
            const preloader = document.getElementById('preloader');
            const predictionDiv = document.getElementById('prediction');

            button.disabled = true;
            preloader.style.display = 'block';
            predictionDiv.style.display = 'none';

            try {
                const data = {
                    name: name,
                    birthDate: birthDate,
                    question: question,
                    mode: mode,
                    partnerName: partnerName,
                    partnerBirth: partnerBirth,
                    step: 1
                };

                console.log('Подготовка данных для запроса:', data);
                
                // Установим максимальное время ожидания в 5 минут
                const timeout = 300000;
                const startTime = Date.now();
                
                // Обновляем индикатор загрузки
                const updateLoader = setInterval(() => {
                    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                    preloader.innerHTML = `Генерируем предсказание... ${elapsedTime} сек.`;
                }, 1000);

                console.log('Отправка запроса на сервер...');
                const response = await fetchWithRetry('/prediction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                clearInterval(updateLoader);
                console.log('Получен ответ от сервера');

                const responseData = await response.json();
                console.log('Данные ответа:', {
                    hasText: !!responseData.text,
                    textLength: responseData.text?.length,
                    hasImages: !!responseData.images,
                    imagesCount: responseData.images?.length,
                    hasPrompts: !!responseData.prompts,
                    promptsCount: responseData.prompts?.length
                });
                
                if (!responseData || !responseData.text) {
                    throw new Error('Получен некорректный ответ от сервера');
                }
                
                let html = `<p>${responseData.text}</p>`;
                
                // Add images if they exist
                if (responseData.images && Array.isArray(responseData.images)) {
                    console.log('Обработка изображений...');
                    for (let i = 0; i < responseData.images.length; i++) {
                        if (responseData.images[i]) {
                            const imageData = responseData.images[i];
                            console.log(`Обработка изображения ${i + 1}`);
                            
                            // Проверяем, является ли imageData массивом байтов или строкой base64
                            let base64Image;
                            if (Array.isArray(imageData)) {
                                console.log('Преобразование массива байтов в base64');
                                base64Image = btoa(String.fromCharCode.apply(null, new Uint8Array(imageData)));
                            } else if (typeof imageData === 'string') {
                                console.log('Использование строки base64');
                                base64Image = imageData;
                            }
                            
                            if (base64Image) {
                                console.log(`Добавление изображения ${i + 1} в HTML`);
                                html += `<img src="data:image/jpeg;base64,${base64Image}" alt="Изображение ${i + 1}">`;
                            }
                        }
                    }
                }

                console.log('Отображение результата');
                predictionDiv.innerHTML = html;
                predictionDiv.style.display = 'block';
            } catch (error) {
                console.error('Ошибка:', error);
                alert('Произошла ошибка при получении предсказания: ' + error.message);
            } finally {
                button.disabled = false;
                preloader.style.display = 'none';
                preloader.innerHTML = '';
            }
        }
    </script>
</body>
</html> 